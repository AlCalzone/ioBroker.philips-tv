{
  "version": 3,
  "sources": ["../src/main.ts"],
  "sourcesContent": ["import * as utils from '@iobroker/adapter-core';\nimport { PhilipsTV, Authentication, PhilipsTVConfig } from 'philips-tv-api';\n\ninterface ApplicationCache {\n    version: number;\n    applications: Application[];\n}\n\ninterface Application {\n    /** Application name */\n    label: string;\n    intent: IntentObject;\n    order: number;\n    id: string;\n    type: string;\n}\n\ninterface IntentObject {\n    component: {\n        packageName: string;\n        className: string;\n    };\n    action: string;\n}\n\ninterface TVCache {\n    version: number;\n    id: string;\n    listType: string;\n    medium: string;\n    operator: string;\n    installCountry: string;\n    Channel: Channel[];\n}\n\ninterface Channel {\n    ccid: number;\n    preset: string;\n    name: string;\n    onid: number;\n    tsid: number;\n    sid: number;\n    serviceType: string;\n    type: string;\n    logoVersion: number;\n}\n\ninterface ActiveChannelObject {\n    channel: Channel;\n    channelList: ChannelList;\n}\n\ninterface ChannelList {\n    id: string;\n    version: string;\n}\n\nclass PhilipsTvAndroid extends utils.Adapter {\n    private tv: PhilipsTV | undefined;\n    private pollingInterval = 5_000;\n    private authTimestamp: number | undefined;\n    private pollTimer: NodeJS.Timer | undefined;\n    private apps: ApplicationCache | undefined;\n    private channels: TVCache | undefined;\n    private ambilightSupported = false;\n    private ambilightPlusHueSupported = false;\n    private firstPoll = true;\n\n    public constructor(options: Partial<utils.AdapterOptions> = {}) {\n        super({\n            ...options,\n            name: 'philips-tv'\n        });\n        this.on('ready', this.onReady.bind(this));\n        this.on('stateChange', this.onStateChange.bind(this));\n        this.on('message', this.onMessage.bind(this));\n        this.on('unload', this.onUnload.bind(this));\n    }\n\n    /**\n     * Is called when databases are connected and adapter received configuration.\n     */\n    private onReady(): void {\n        if (!this.config.ip) {\n            this.log.warn('Please specify ip before starting the adapter');\n            return;\n        }\n\n        if (this.config.pollingInterval) {\n            this.pollingInterval = this.config.pollingInterval;\n        }\n\n        // Ensure that v1 and v5 are only selected as Jointspace\n        this.config.apiType = this.config.apiVersion === 6 ? this.config.apiType : 'Jointspace';\n\n        this.log.info(`Starting with ip \"${this.config.ip}\" (API v${this.config.apiVersion} - ${this.config.apiType})`);\n\n        this.subscribeStates('*');\n\n        const auth: Authentication = {\n            user: this.config.apiUser,\n            pass: this.config.apiPass,\n            sendImmediately: false\n        };\n\n        const tvConfig: PhilipsTVConfig = {\n            apiVersion: this.config.apiVersion,\n            wakeUntilAPIReadyCounter: 100,\n            broadcastIP: this.config.broadcastIp,\n            wakeOnLanRequests: 1,\n            wakeOnLanTimeout: 1_000,\n            apiType: this.config.apiType\n        };\n\n        try {\n            this.tv = new PhilipsTV(this.config.ip, this.config.mac, auth, tvConfig, 'ioBroker');\n\n            if (!(this.config.apiUser || this.config.apiPass) && this.tv.requiresPairing()) {\n                this.log.warn('Please authenticate via the adapter configuration page');\n                return;\n            }\n\n            this.pollTimer = setTimeout(() => {\n                this.pollAPI();\n            }, this.pollingInterval);\n        } catch (e) {\n            this.log.error(`Cannot create API client ${this.errorToText(e)}`);\n        }\n    }\n\n    /**\n     * Is called when adapter shuts down - callback has to be called under any circumstances!\n     */\n    private async onUnload(callback: () => void): Promise<void> {\n        try {\n            if (this.pollTimer) {\n                clearTimeout(this.pollTimer);\n            }\n\n            await this.setStateAsync('settings.power', false, true);\n            await this.setStateAsync('info.connection', false, true);\n\n            callback();\n        } catch {\n            callback();\n        }\n    }\n\n    /**\n     * Is called if a subscribed state changes\n     */\n    private async onStateChange(id: string, state: ioBroker.State | null | undefined): Promise<void> {\n        if (!state || state.ack) {\n            return;\n        }\n        this.log.debug(`state change ${id}: ${state.val}`);\n\n        const idParts = id.split('.');\n\n        const command = idParts.pop() as string;\n        const channel = idParts.pop() as string;\n\n        if (!this.tv) {\n            this.log.warn(`Ignoring state change of \"${id}\", because TV is not ready`);\n            return;\n        }\n\n        if (channel === 'keys') {\n            const keyName = command.charAt(0).toUpperCase() + command.substring(1);\n            this.log.debug(`Sending key \"${keyName}\"`);\n            try {\n                await this.tv.sendKey(keyName);\n            } catch (e) {\n                this.log.error(`Could not send key \"${keyName}\": ${this.errorToText(e)}`);\n            }\n            return;\n        }\n\n        switch (command) {\n            case 'power':\n                try {\n                    if (this.config.mac && state.val) {\n                        this.log.debug(`WOL to ${this.config.mac}`);\n                        await this.tv.turnOn();\n                    } else {\n                        await this.tv.setPowerState(state.val as boolean);\n                    }\n                } catch (e) {\n                    this.log.error(`Could not change power state: ${this.errorToText(e)}`);\n                }\n                break;\n            case 'volume':\n                try {\n                    await this.tv.setVolume(state.val as number);\n                } catch (e) {\n                    this.log.error(`Could not change volume: ${this.errorToText(e)}`);\n                }\n                break;\n            case 'muted':\n                try {\n                    await this.tv.setMute(state.val as boolean);\n                } catch (e) {\n                    this.log.error(`Could not change mute status: ${this.errorToText(e)}`);\n                }\n                break;\n            case 'launchApp':\n                const appName = state.val as string;\n\n                if (!this.apps) {\n                    this.log.error(`No apps cached, cannot launch \"${appName}\"`);\n                    return;\n                }\n\n                const matchingApp = this.apps.applications.find(entry => entry.label === appName);\n\n                if (matchingApp) {\n                    try {\n                        await this.tv.launchApplication(matchingApp as any);\n                    } catch (e) {\n                        this.log.error(`Could not launch application \"${appName}\": ${this.errorToText(e)}`);\n                    }\n                } else {\n                    this.log.error(`Application \"${appName}\" not found`);\n                }\n                break;\n            case 'launchTvChannel':\n                const channelName = state.val as string;\n\n                if (!this.channels) {\n                    this.log.error(`No channels cached, cannot launch \"${channelName}\"`);\n                    return;\n                }\n\n                const matchingChannel = this.channels.Channel.find(entry => entry.name === channelName);\n\n                if (matchingChannel) {\n                    try {\n                        const requestedChannel: Partial<ActiveChannelObject> = { channel: matchingChannel };\n\n                        const currentChannel = (await this.tv.getCurrentTVChannel()) as ActiveChannelObject;\n                        requestedChannel.channelList = currentChannel.channelList;\n\n                        await this.tv.launchTVChannel(requestedChannel as any);\n                    } catch (e) {\n                        this.log.error(`Could not launch TV channel \"${channelName}\": ${this.errorToText(e)}`);\n                    }\n                } else {\n                    this.log.error(`Channel \"${channelName}\" not found`);\n                }\n                break;\n            case 'ambilightPlusHueActive':\n                try {\n                    await this.tv.setAmbilightPlusHueState(state.val as boolean);\n                } catch (e) {\n                    this.log.error(`Could not change Ambilight + Hue state: ${this.errorToText(e)}`);\n                }\n                break;\n            case 'ambilightActive':\n                try {\n                    await this.tv.setAmbilightState(state.val as boolean);\n                } catch (e) {\n                    this.log.error(`Could not change Ambilight state: ${this.errorToText(e)}`);\n                }\n                break;\n            case 'customAmbilightCommand':\n                try {\n                    await this.tv.sendCustomAmbilightCmd(JSON.parse(state.val as string));\n                    await this.setForeignStateAsync(id, state.val, true);\n                } catch (e) {\n                    this.log.error(`Could not send custom Ambilight command: ${this.errorToText(e)}`);\n                }\n                break;\n            case 'hdmiInputGoogleAssistant':\n                const googleAssistantCommand = {\n                    intent: {\n                        extras: { query: `HDMI ${state.val}` },\n                        action: 'Intent {  act=android.intent.action.ASSIST cmp=com.google.android.katniss/com.google.android.apps.tvsearch.app.launch.trampoline.SearchActivityTrampoline flg=0x10200000 }',\n                        component: {\n                            packageName: 'com.google.android.katniss',\n                            className: 'com.google.android.apps.tvsearch.app.launch.trampoline.SearchActivityTrampoline'\n                        }\n                    }\n                };\n\n                await this.tv.launchApplication(googleAssistantCommand as any);\n                break;\n            default:\n                this.log.warn(`No command implemented for stateChange of \"${id}\"`);\n        }\n    }\n\n    /**\n     * Handle messages send to this instance\n     * @param obj the message object\n     */\n    private async onMessage(obj: ioBroker.Message): Promise<void> {\n        if (typeof obj.message !== 'string') {\n            this.sendTo(\n                obj.from,\n                obj.command,\n                { error: `Unknown message payload for \"${obj.command}\": ${JSON.stringify(obj.message)}` },\n                obj.callback\n            );\n            return;\n        }\n\n        if (obj.command === 'pairing') {\n            try {\n                await this.startPairing(obj.message);\n            } catch (e: any) {\n                if (e.message === 'ETIMEDOUT') {\n                    this.sendTo(obj.from, obj.command, { error: 'Timeout' }, obj.callback);\n                } else {\n                    this.sendTo(obj.from, obj.command, { error: e.message }, obj.callback);\n                }\n            }\n        } else if (obj.command === 'submitPin') {\n            if (!this.authTimestamp) {\n                this.sendTo(\n                    obj.from,\n                    obj.command,\n                    { error: 'You need to request pairing before you can enter the PIN code' },\n                    obj.callback\n                );\n                return;\n            }\n            try {\n                await this.performAuthentication(this.authTimestamp, obj.message);\n            } catch (e) {\n                this.sendTo(obj.from, obj.command, { error: this.errorToText(e) }, obj.callback);\n            }\n        }\n\n        this.sendTo(obj.from, obj.command, {}, obj.callback);\n    }\n\n    /**\n     * Starts the pairing procedure\n     *\n     * @param ip address to pair with\n     */\n    private async startPairing(ip: string): Promise<void> {\n        this.log.info('Start pairing process');\n\n        this.tv = new PhilipsTV(ip, undefined, undefined, undefined, 'ioBroker');\n        const result = await this.tv.requestPair();\n        if (typeof result.timestamp === 'number') {\n            this.authTimestamp = result.timestamp;\n        }\n    }\n\n    /**\n     * Performs the authentication with given pin\n     * @param timestamp timestamp of pairing request\n     * @param pin pin shown on tv\n     */\n    private async performAuthentication(timestamp: number, pin: string): Promise<void> {\n        if (!this.tv) {\n            this.log.warn('Pairing needs to be started before performing authentication');\n            return;\n        }\n        const res = await this.tv.authorizePair(timestamp as any, pin);\n        // res.apiUser and res.apiPass\n        const instanceObj = await this.getForeignObjectAsync(`system.adapter.${this.namespace}`);\n        if (instanceObj) {\n            instanceObj.native.apiUser = res.apiUser;\n            instanceObj.native.apiPass = res.apiPass;\n            await this.setForeignObjectAsync(`system.adapter.${this.namespace}`, instanceObj);\n        }\n    }\n\n    /**\n     * Polls states from API and syncs them to ioBroker\n     */\n    private async pollAPI(): Promise<void> {\n        if (!this.tv) {\n            return;\n        }\n\n        try {\n            const volumeRes = await this.tv.getVolume();\n            await this.setStateAsync('settings.volume', volumeRes.current, true);\n            await this.setStateAsync('settings.muted', volumeRes.muted, true);\n\n            const powerRes = await this.tv.getPowerState();\n            await this.setStateAsync('settings.power', powerRes.powerstate === 'On', true);\n            await this.setStateChangedAsync('info.connection', true, true);\n\n            if (this.ambilightSupported) {\n                const ambiState = await this.tv.getAmbilightState();\n                await this.setStateAsync('settings.ambilightActive', ambiState, true);\n            }\n\n            if (this.ambilightPlusHueSupported) {\n                const ambiHueState = await this.tv.getAmbilightPlusHueState();\n                await this.setStateAsync('settings.ambilightPlusHueActive', ambiHueState, true);\n            }\n\n            if (this.firstPoll) {\n                // do this only once per run\n                this.firstPoll = false;\n                await this.cacheApps();\n                await this.cacheChannels();\n\n                // also extend the min/max correctly for volume once\n                await this.extendObjectAsync('settings.volume', { common: { min: volumeRes.min, max: volumeRes.max } });\n                await this.checkAmbilightPlusHueSupport();\n                await this.checkAmbilightSupport();\n                await this.syncSystemInfo();\n            }\n        } catch (e: any) {\n            if (\n                e.code === 'ECONNREFUSED' ||\n                e.code === 'ETIMEDOUT' ||\n                e.code === 'ESOCKETTIMEDOUT' ||\n                e.code === 'EHOSTUNREACH'\n            ) {\n                this.log.debug('The TV seems to be turned off');\n            } else {\n                this.log.error(`Could not poll API: ${this.errorToText(e)}`);\n            }\n            await this.setStateChangedAsync('settings.power', false, true);\n            await this.setStateChangedAsync('info.connection', false, true);\n        }\n\n        this.pollTimer = setTimeout(() => {\n            this.pollAPI();\n        }, this.pollingInterval);\n    }\n\n    /**\n     * Cache apps and ensure object has the cached information\n     */\n    private async cacheApps(): Promise<void> {\n        try {\n            this.apps = (await this.tv!.getApplications()) as ApplicationCache;\n            const appLabels = this.apps.applications.map(entry => entry.label);\n            await this.extendObjectAsync('settings.launchApp', {\n                type: 'state',\n                common: {\n                    role: 'text',\n                    name: 'Launch application',\n                    type: 'string',\n                    read: false,\n                    write: true,\n                    states: appLabels\n                },\n                native: {}\n            });\n\n            await this.extendObjectAsync('settings.hdmiInputGoogleAssistant', {\n                type: 'state',\n                common: {\n                    role: 'value',\n                    name: 'Switch HDMI input',\n                    type: 'number',\n                    read: false,\n                    write: true\n                },\n                native: {}\n            });\n        } catch (e) {\n            this.log.debug(`No app launch support: ${this.errorToText(e)}`);\n        }\n    }\n\n    /**\n     * Cache channels and ensure object has the cached information\n     */\n    private async cacheChannels(): Promise<void> {\n        try {\n            this.channels = (await this.tv!.getTVChannels()) as TVCache;\n            const channelNames = this.channels.Channel.map(entry => entry.name);\n            await this.extendObjectAsync('settings.launchTvChannel', {\n                type: 'state',\n                common: {\n                    role: 'text',\n                    name: 'Launch TV channel',\n                    type: 'string',\n                    read: false,\n                    write: true,\n                    states: channelNames\n                },\n                native: {}\n            });\n        } catch (e) {\n            this.log.debug(`No channel launch support: ${this.errorToText(e)}`);\n        }\n    }\n\n    /**\n     * Checks if the TV supports ambilight, if so the state is created an flag is set\n     */\n    private async checkAmbilightSupport(): Promise<void> {\n        try {\n            const ambiHueState = await this.tv!.getAmbilightState();\n\n            await this.extendObjectAsync('settings.ambilightActive', {\n                type: 'state',\n                common: {\n                    role: 'switch',\n                    name: 'Ambilight activation status',\n                    type: 'boolean',\n                    read: true,\n                    write: true\n                },\n                native: {}\n            });\n\n            await this.extendObjectAsync('settings.customAmbilightCommand', {\n                type: 'state',\n                common: {\n                    role: 'json',\n                    name: 'Send custom Ambilight command',\n                    type: 'string',\n                    read: false,\n                    write: true,\n                    def: '{\"styleName\":\"FOLLOW_VIDEO\",\"isExpert\":false,\"menuSetting\":\"GAME\"}'\n                },\n                native: {}\n            });\n\n            await this.setStateAsync('settings.ambilightActive', ambiHueState, true);\n            this.ambilightSupported = true;\n        } catch (e) {\n            this.ambilightSupported = false;\n            this.log.debug(`No Ambilight plus Hue support: ${this.errorToText(e)}`);\n        }\n    }\n\n    /**\n     * Checks if the TV supports ambilight plus Hue, if so the state is created an flag is set\n     */\n    private async checkAmbilightPlusHueSupport(): Promise<void> {\n        try {\n            const ambiHueState = await this.tv!.getAmbilightPlusHueState();\n\n            await this.extendObjectAsync('settings.ambilightPlusHueActive', {\n                type: 'state',\n                common: {\n                    role: 'switch',\n                    name: 'Ambilight + Hue activation status',\n                    type: 'boolean',\n                    read: true,\n                    write: true\n                },\n                native: {}\n            });\n\n            await this.setStateAsync('settings.ambilightPlusHueActive', ambiHueState, true);\n            this.ambilightPlusHueSupported = true;\n        } catch (e) {\n            this.ambilightPlusHueSupported = false;\n            this.log.debug(`No Ambilight plus Hue support: ${this.errorToText(e)}`);\n        }\n    }\n\n    private async syncSystemInfo(): Promise<void> {\n        try {\n            const res = await this.tv!.info();\n            await this.extendForeignObjectAsync(this.namespace, {\n                // @ts-expect-error we are allowed to create this as device\n                type: 'device',\n                common: {\n                    // @ts-expect-error types in lib missing\n                    name: res.name\n                },\n                native: res\n            });\n        } catch (e) {\n            this.log.error(`Could not synchronize system information: ${this.errorToText(e)}`);\n        }\n    }\n\n    /**\n     * Checks if a real error was thrown and returns message, else it stringifies\n     *\n     * @param error any kind of thrown error\n     */\n    private errorToText(error: unknown): string {\n        if (error instanceof Error) {\n            return error.message;\n        } else {\n            return JSON.stringify(error);\n        }\n    }\n}\n\nif (require.main !== module) {\n    // Export the constructor in compact mode\n    module.exports = (options: Partial<utils.AdapterOptions> | undefined) => new PhilipsTvAndroid(options);\n} else {\n    // otherwise start the instance directly\n    (() => new PhilipsTvAndroid())();\n}\n"],
  "mappings": ";;;;;;;;;;;;;;;;;;;AAAA,YAAuB;AACvB,4BAA2D;AAwD3D,MAAM,yBAAyB,MAAM,QAAQ;AAAA,EAWlC,YAAY,UAAyC,CAAC,GAAG;AAC5D,UAAM;AAAA,MACF,GAAG;AAAA,MACH,MAAM;AAAA,IACV,CAAC;AAbL,SAAQ,kBAAkB;AAK1B,SAAQ,qBAAqB;AAC7B,SAAQ,4BAA4B;AACpC,SAAQ,YAAY;AAOhB,SAAK,GAAG,SAAS,KAAK,QAAQ,KAAK,IAAI,CAAC;AACxC,SAAK,GAAG,eAAe,KAAK,cAAc,KAAK,IAAI,CAAC;AACpD,SAAK,GAAG,WAAW,KAAK,UAAU,KAAK,IAAI,CAAC;AAC5C,SAAK,GAAG,UAAU,KAAK,SAAS,KAAK,IAAI,CAAC;AAAA,EAC9C;AAAA,EAKQ,UAAgB;AACpB,QAAI,CAAC,KAAK,OAAO,IAAI;AACjB,WAAK,IAAI,KAAK,+CAA+C;AAC7D;AAAA,IACJ;AAEA,QAAI,KAAK,OAAO,iBAAiB;AAC7B,WAAK,kBAAkB,KAAK,OAAO;AAAA,IACvC;AAGA,SAAK,OAAO,UAAU,KAAK,OAAO,eAAe,IAAI,KAAK,OAAO,UAAU;AAE3E,SAAK,IAAI,KAAK,qBAAqB,KAAK,OAAO,aAAa,KAAK,OAAO,gBAAgB,KAAK,OAAO,UAAU;AAE9G,SAAK,gBAAgB,GAAG;AAExB,UAAM,OAAuB;AAAA,MACzB,MAAM,KAAK,OAAO;AAAA,MAClB,MAAM,KAAK,OAAO;AAAA,MAClB,iBAAiB;AAAA,IACrB;AAEA,UAAM,WAA4B;AAAA,MAC9B,YAAY,KAAK,OAAO;AAAA,MACxB,0BAA0B;AAAA,MAC1B,aAAa,KAAK,OAAO;AAAA,MACzB,mBAAmB;AAAA,MACnB,kBAAkB;AAAA,MAClB,SAAS,KAAK,OAAO;AAAA,IACzB;AAEA,QAAI;AACA,WAAK,KAAK,IAAI,gCAAU,KAAK,OAAO,IAAI,KAAK,OAAO,KAAK,MAAM,UAAU,UAAU;AAEnF,UAAI,EAAE,KAAK,OAAO,WAAW,KAAK,OAAO,YAAY,KAAK,GAAG,gBAAgB,GAAG;AAC5E,aAAK,IAAI,KAAK,wDAAwD;AACtE;AAAA,MACJ;AAEA,WAAK,YAAY,WAAW,MAAM;AAC9B,aAAK,QAAQ;AAAA,MACjB,GAAG,KAAK,eAAe;AAAA,IAC3B,SAAS,GAAP;AACE,WAAK,IAAI,MAAM,4BAA4B,KAAK,YAAY,CAAC,GAAG;AAAA,IACpE;AAAA,EACJ;AAAA,EAKA,MAAc,SAAS,UAAqC;AACxD,QAAI;AACA,UAAI,KAAK,WAAW;AAChB,qBAAa,KAAK,SAAS;AAAA,MAC/B;AAEA,YAAM,KAAK,cAAc,kBAAkB,OAAO,IAAI;AACtD,YAAM,KAAK,cAAc,mBAAmB,OAAO,IAAI;AAEvD,eAAS;AAAA,IACb,QAAE;AACE,eAAS;AAAA,IACb;AAAA,EACJ;AAAA,EAKA,MAAc,cAAc,IAAY,OAAyD;AAC7F,QAAI,CAAC,SAAS,MAAM,KAAK;AACrB;AAAA,IACJ;AACA,SAAK,IAAI,MAAM,gBAAgB,OAAO,MAAM,KAAK;AAEjD,UAAM,UAAU,GAAG,MAAM,GAAG;AAE5B,UAAM,UAAU,QAAQ,IAAI;AAC5B,UAAM,UAAU,QAAQ,IAAI;AAE5B,QAAI,CAAC,KAAK,IAAI;AACV,WAAK,IAAI,KAAK,6BAA6B,8BAA8B;AACzE;AAAA,IACJ;AAEA,QAAI,YAAY,QAAQ;AACpB,YAAM,UAAU,QAAQ,OAAO,CAAC,EAAE,YAAY,IAAI,QAAQ,UAAU,CAAC;AACrE,WAAK,IAAI,MAAM,gBAAgB,UAAU;AACzC,UAAI;AACA,cAAM,KAAK,GAAG,QAAQ,OAAO;AAAA,MACjC,SAAS,GAAP;AACE,aAAK,IAAI,MAAM,uBAAuB,aAAa,KAAK,YAAY,CAAC,GAAG;AAAA,MAC5E;AACA;AAAA,IACJ;AAEA,YAAQ;AAAA,WACC;AACD,YAAI;AACA,cAAI,KAAK,OAAO,OAAO,MAAM,KAAK;AAC9B,iBAAK,IAAI,MAAM,UAAU,KAAK,OAAO,KAAK;AAC1C,kBAAM,KAAK,GAAG,OAAO;AAAA,UACzB,OAAO;AACH,kBAAM,KAAK,GAAG,cAAc,MAAM,GAAc;AAAA,UACpD;AAAA,QACJ,SAAS,GAAP;AACE,eAAK,IAAI,MAAM,iCAAiC,KAAK,YAAY,CAAC,GAAG;AAAA,QACzE;AACA;AAAA,WACC;AACD,YAAI;AACA,gBAAM,KAAK,GAAG,UAAU,MAAM,GAAa;AAAA,QAC/C,SAAS,GAAP;AACE,eAAK,IAAI,MAAM,4BAA4B,KAAK,YAAY,CAAC,GAAG;AAAA,QACpE;AACA;AAAA,WACC;AACD,YAAI;AACA,gBAAM,KAAK,GAAG,QAAQ,MAAM,GAAc;AAAA,QAC9C,SAAS,GAAP;AACE,eAAK,IAAI,MAAM,iCAAiC,KAAK,YAAY,CAAC,GAAG;AAAA,QACzE;AACA;AAAA,WACC;AACD,cAAM,UAAU,MAAM;AAEtB,YAAI,CAAC,KAAK,MAAM;AACZ,eAAK,IAAI,MAAM,kCAAkC,UAAU;AAC3D;AAAA,QACJ;AAEA,cAAM,cAAc,KAAK,KAAK,aAAa,KAAK,WAAS,MAAM,UAAU,OAAO;AAEhF,YAAI,aAAa;AACb,cAAI;AACA,kBAAM,KAAK,GAAG,kBAAkB,WAAkB;AAAA,UACtD,SAAS,GAAP;AACE,iBAAK,IAAI,MAAM,iCAAiC,aAAa,KAAK,YAAY,CAAC,GAAG;AAAA,UACtF;AAAA,QACJ,OAAO;AACH,eAAK,IAAI,MAAM,gBAAgB,oBAAoB;AAAA,QACvD;AACA;AAAA,WACC;AACD,cAAM,cAAc,MAAM;AAE1B,YAAI,CAAC,KAAK,UAAU;AAChB,eAAK,IAAI,MAAM,sCAAsC,cAAc;AACnE;AAAA,QACJ;AAEA,cAAM,kBAAkB,KAAK,SAAS,QAAQ,KAAK,WAAS,MAAM,SAAS,WAAW;AAEtF,YAAI,iBAAiB;AACjB,cAAI;AACA,kBAAM,mBAAiD,EAAE,SAAS,gBAAgB;AAElF,kBAAM,iBAAkB,MAAM,KAAK,GAAG,oBAAoB;AAC1D,6BAAiB,cAAc,eAAe;AAE9C,kBAAM,KAAK,GAAG,gBAAgB,gBAAuB;AAAA,UACzD,SAAS,GAAP;AACE,iBAAK,IAAI,MAAM,gCAAgC,iBAAiB,KAAK,YAAY,CAAC,GAAG;AAAA,UACzF;AAAA,QACJ,OAAO;AACH,eAAK,IAAI,MAAM,YAAY,wBAAwB;AAAA,QACvD;AACA;AAAA,WACC;AACD,YAAI;AACA,gBAAM,KAAK,GAAG,yBAAyB,MAAM,GAAc;AAAA,QAC/D,SAAS,GAAP;AACE,eAAK,IAAI,MAAM,2CAA2C,KAAK,YAAY,CAAC,GAAG;AAAA,QACnF;AACA;AAAA,WACC;AACD,YAAI;AACA,gBAAM,KAAK,GAAG,kBAAkB,MAAM,GAAc;AAAA,QACxD,SAAS,GAAP;AACE,eAAK,IAAI,MAAM,qCAAqC,KAAK,YAAY,CAAC,GAAG;AAAA,QAC7E;AACA;AAAA,WACC;AACD,YAAI;AACA,gBAAM,KAAK,GAAG,uBAAuB,KAAK,MAAM,MAAM,GAAa,CAAC;AACpE,gBAAM,KAAK,qBAAqB,IAAI,MAAM,KAAK,IAAI;AAAA,QACvD,SAAS,GAAP;AACE,eAAK,IAAI,MAAM,4CAA4C,KAAK,YAAY,CAAC,GAAG;AAAA,QACpF;AACA;AAAA,WACC;AACD,cAAM,yBAAyB;AAAA,UAC3B,QAAQ;AAAA,YACJ,QAAQ,EAAE,OAAO,QAAQ,MAAM,MAAM;AAAA,YACrC,QAAQ;AAAA,YACR,WAAW;AAAA,cACP,aAAa;AAAA,cACb,WAAW;AAAA,YACf;AAAA,UACJ;AAAA,QACJ;AAEA,cAAM,KAAK,GAAG,kBAAkB,sBAA6B;AAC7D;AAAA;AAEA,aAAK,IAAI,KAAK,8CAA8C,KAAK;AAAA;AAAA,EAE7E;AAAA,EAMA,MAAc,UAAU,KAAsC;AAC1D,QAAI,OAAO,IAAI,YAAY,UAAU;AACjC,WAAK;AAAA,QACD,IAAI;AAAA,QACJ,IAAI;AAAA,QACJ,EAAE,OAAO,gCAAgC,IAAI,aAAa,KAAK,UAAU,IAAI,OAAO,IAAI;AAAA,QACxF,IAAI;AAAA,MACR;AACA;AAAA,IACJ;AAEA,QAAI,IAAI,YAAY,WAAW;AAC3B,UAAI;AACA,cAAM,KAAK,aAAa,IAAI,OAAO;AAAA,MACvC,SAAS,GAAP;AACE,YAAI,EAAE,YAAY,aAAa;AAC3B,eAAK,OAAO,IAAI,MAAM,IAAI,SAAS,EAAE,OAAO,UAAU,GAAG,IAAI,QAAQ;AAAA,QACzE,OAAO;AACH,eAAK,OAAO,IAAI,MAAM,IAAI,SAAS,EAAE,OAAO,EAAE,QAAQ,GAAG,IAAI,QAAQ;AAAA,QACzE;AAAA,MACJ;AAAA,IACJ,WAAW,IAAI,YAAY,aAAa;AACpC,UAAI,CAAC,KAAK,eAAe;AACrB,aAAK;AAAA,UACD,IAAI;AAAA,UACJ,IAAI;AAAA,UACJ,EAAE,OAAO,gEAAgE;AAAA,UACzE,IAAI;AAAA,QACR;AACA;AAAA,MACJ;AACA,UAAI;AACA,cAAM,KAAK,sBAAsB,KAAK,eAAe,IAAI,OAAO;AAAA,MACpE,SAAS,GAAP;AACE,aAAK,OAAO,IAAI,MAAM,IAAI,SAAS,EAAE,OAAO,KAAK,YAAY,CAAC,EAAE,GAAG,IAAI,QAAQ;AAAA,MACnF;AAAA,IACJ;AAEA,SAAK,OAAO,IAAI,MAAM,IAAI,SAAS,CAAC,GAAG,IAAI,QAAQ;AAAA,EACvD;AAAA,EAOA,MAAc,aAAa,IAA2B;AAClD,SAAK,IAAI,KAAK,uBAAuB;AAErC,SAAK,KAAK,IAAI,gCAAU,IAAI,QAAW,QAAW,QAAW,UAAU;AACvE,UAAM,SAAS,MAAM,KAAK,GAAG,YAAY;AACzC,QAAI,OAAO,OAAO,cAAc,UAAU;AACtC,WAAK,gBAAgB,OAAO;AAAA,IAChC;AAAA,EACJ;AAAA,EAOA,MAAc,sBAAsB,WAAmB,KAA4B;AAC/E,QAAI,CAAC,KAAK,IAAI;AACV,WAAK,IAAI,KAAK,8DAA8D;AAC5E;AAAA,IACJ;AACA,UAAM,MAAM,MAAM,KAAK,GAAG,cAAc,WAAkB,GAAG;AAE7D,UAAM,cAAc,MAAM,KAAK,sBAAsB,kBAAkB,KAAK,WAAW;AACvF,QAAI,aAAa;AACb,kBAAY,OAAO,UAAU,IAAI;AACjC,kBAAY,OAAO,UAAU,IAAI;AACjC,YAAM,KAAK,sBAAsB,kBAAkB,KAAK,aAAa,WAAW;AAAA,IACpF;AAAA,EACJ;AAAA,EAKA,MAAc,UAAyB;AACnC,QAAI,CAAC,KAAK,IAAI;AACV;AAAA,IACJ;AAEA,QAAI;AACA,YAAM,YAAY,MAAM,KAAK,GAAG,UAAU;AAC1C,YAAM,KAAK,cAAc,mBAAmB,UAAU,SAAS,IAAI;AACnE,YAAM,KAAK,cAAc,kBAAkB,UAAU,OAAO,IAAI;AAEhE,YAAM,WAAW,MAAM,KAAK,GAAG,cAAc;AAC7C,YAAM,KAAK,cAAc,kBAAkB,SAAS,eAAe,MAAM,IAAI;AAC7E,YAAM,KAAK,qBAAqB,mBAAmB,MAAM,IAAI;AAE7D,UAAI,KAAK,oBAAoB;AACzB,cAAM,YAAY,MAAM,KAAK,GAAG,kBAAkB;AAClD,cAAM,KAAK,cAAc,4BAA4B,WAAW,IAAI;AAAA,MACxE;AAEA,UAAI,KAAK,2BAA2B;AAChC,cAAM,eAAe,MAAM,KAAK,GAAG,yBAAyB;AAC5D,cAAM,KAAK,cAAc,mCAAmC,cAAc,IAAI;AAAA,MAClF;AAEA,UAAI,KAAK,WAAW;AAEhB,aAAK,YAAY;AACjB,cAAM,KAAK,UAAU;AACrB,cAAM,KAAK,cAAc;AAGzB,cAAM,KAAK,kBAAkB,mBAAmB,EAAE,QAAQ,EAAE,KAAK,UAAU,KAAK,KAAK,UAAU,IAAI,EAAE,CAAC;AACtG,cAAM,KAAK,6BAA6B;AACxC,cAAM,KAAK,sBAAsB;AACjC,cAAM,KAAK,eAAe;AAAA,MAC9B;AAAA,IACJ,SAAS,GAAP;AACE,UACI,EAAE,SAAS,kBACX,EAAE,SAAS,eACX,EAAE,SAAS,qBACX,EAAE,SAAS,gBACb;AACE,aAAK,IAAI,MAAM,+BAA+B;AAAA,MAClD,OAAO;AACH,aAAK,IAAI,MAAM,uBAAuB,KAAK,YAAY,CAAC,GAAG;AAAA,MAC/D;AACA,YAAM,KAAK,qBAAqB,kBAAkB,OAAO,IAAI;AAC7D,YAAM,KAAK,qBAAqB,mBAAmB,OAAO,IAAI;AAAA,IAClE;AAEA,SAAK,YAAY,WAAW,MAAM;AAC9B,WAAK,QAAQ;AAAA,IACjB,GAAG,KAAK,eAAe;AAAA,EAC3B;AAAA,EAKA,MAAc,YAA2B;AACrC,QAAI;AACA,WAAK,OAAQ,MAAM,KAAK,GAAI,gBAAgB;AAC5C,YAAM,YAAY,KAAK,KAAK,aAAa,IAAI,WAAS,MAAM,KAAK;AACjE,YAAM,KAAK,kBAAkB,sBAAsB;AAAA,QAC/C,MAAM;AAAA,QACN,QAAQ;AAAA,UACJ,MAAM;AAAA,UACN,MAAM;AAAA,UACN,MAAM;AAAA,UACN,MAAM;AAAA,UACN,OAAO;AAAA,UACP,QAAQ;AAAA,QACZ;AAAA,QACA,QAAQ,CAAC;AAAA,MACb,CAAC;AAED,YAAM,KAAK,kBAAkB,qCAAqC;AAAA,QAC9D,MAAM;AAAA,QACN,QAAQ;AAAA,UACJ,MAAM;AAAA,UACN,MAAM;AAAA,UACN,MAAM;AAAA,UACN,MAAM;AAAA,UACN,OAAO;AAAA,QACX;AAAA,QACA,QAAQ,CAAC;AAAA,MACb,CAAC;AAAA,IACL,SAAS,GAAP;AACE,WAAK,IAAI,MAAM,0BAA0B,KAAK,YAAY,CAAC,GAAG;AAAA,IAClE;AAAA,EACJ;AAAA,EAKA,MAAc,gBAA+B;AACzC,QAAI;AACA,WAAK,WAAY,MAAM,KAAK,GAAI,cAAc;AAC9C,YAAM,eAAe,KAAK,SAAS,QAAQ,IAAI,WAAS,MAAM,IAAI;AAClE,YAAM,KAAK,kBAAkB,4BAA4B;AAAA,QACrD,MAAM;AAAA,QACN,QAAQ;AAAA,UACJ,MAAM;AAAA,UACN,MAAM;AAAA,UACN,MAAM;AAAA,UACN,MAAM;AAAA,UACN,OAAO;AAAA,UACP,QAAQ;AAAA,QACZ;AAAA,QACA,QAAQ,CAAC;AAAA,MACb,CAAC;AAAA,IACL,SAAS,GAAP;AACE,WAAK,IAAI,MAAM,8BAA8B,KAAK,YAAY,CAAC,GAAG;AAAA,IACtE;AAAA,EACJ;AAAA,EAKA,MAAc,wBAAuC;AACjD,QAAI;AACA,YAAM,eAAe,MAAM,KAAK,GAAI,kBAAkB;AAEtD,YAAM,KAAK,kBAAkB,4BAA4B;AAAA,QACrD,MAAM;AAAA,QACN,QAAQ;AAAA,UACJ,MAAM;AAAA,UACN,MAAM;AAAA,UACN,MAAM;AAAA,UACN,MAAM;AAAA,UACN,OAAO;AAAA,QACX;AAAA,QACA,QAAQ,CAAC;AAAA,MACb,CAAC;AAED,YAAM,KAAK,kBAAkB,mCAAmC;AAAA,QAC5D,MAAM;AAAA,QACN,QAAQ;AAAA,UACJ,MAAM;AAAA,UACN,MAAM;AAAA,UACN,MAAM;AAAA,UACN,MAAM;AAAA,UACN,OAAO;AAAA,UACP,KAAK;AAAA,QACT;AAAA,QACA,QAAQ,CAAC;AAAA,MACb,CAAC;AAED,YAAM,KAAK,cAAc,4BAA4B,cAAc,IAAI;AACvE,WAAK,qBAAqB;AAAA,IAC9B,SAAS,GAAP;AACE,WAAK,qBAAqB;AAC1B,WAAK,IAAI,MAAM,kCAAkC,KAAK,YAAY,CAAC,GAAG;AAAA,IAC1E;AAAA,EACJ;AAAA,EAKA,MAAc,+BAA8C;AACxD,QAAI;AACA,YAAM,eAAe,MAAM,KAAK,GAAI,yBAAyB;AAE7D,YAAM,KAAK,kBAAkB,mCAAmC;AAAA,QAC5D,MAAM;AAAA,QACN,QAAQ;AAAA,UACJ,MAAM;AAAA,UACN,MAAM;AAAA,UACN,MAAM;AAAA,UACN,MAAM;AAAA,UACN,OAAO;AAAA,QACX;AAAA,QACA,QAAQ,CAAC;AAAA,MACb,CAAC;AAED,YAAM,KAAK,cAAc,mCAAmC,cAAc,IAAI;AAC9E,WAAK,4BAA4B;AAAA,IACrC,SAAS,GAAP;AACE,WAAK,4BAA4B;AACjC,WAAK,IAAI,MAAM,kCAAkC,KAAK,YAAY,CAAC,GAAG;AAAA,IAC1E;AAAA,EACJ;AAAA,EAEA,MAAc,iBAAgC;AAC1C,QAAI;AACA,YAAM,MAAM,MAAM,KAAK,GAAI,KAAK;AAChC,YAAM,KAAK,yBAAyB,KAAK,WAAW;AAAA,QAEhD,MAAM;AAAA,QACN,QAAQ;AAAA,UAEJ,MAAM,IAAI;AAAA,QACd;AAAA,QACA,QAAQ;AAAA,MACZ,CAAC;AAAA,IACL,SAAS,GAAP;AACE,WAAK,IAAI,MAAM,6CAA6C,KAAK,YAAY,CAAC,GAAG;AAAA,IACrF;AAAA,EACJ;AAAA,EAOQ,YAAY,OAAwB;AACxC,QAAI,iBAAiB,OAAO;AACxB,aAAO,MAAM;AAAA,IACjB,OAAO;AACH,aAAO,KAAK,UAAU,KAAK;AAAA,IAC/B;AAAA,EACJ;AACJ;AAEA,IAAI,QAAQ,SAAS,QAAQ;AAEzB,SAAO,UAAU,CAAC,YAAuD,IAAI,iBAAiB,OAAO;AACzG,OAAO;AAEH,GAAC,MAAM,IAAI,iBAAiB,GAAG;AACnC;",
  "names": []
}
