{"version":3,"file":"./admin/build/main.bundle.js","sources":["webpack:///./admin/src/index.tsx","webpack:///./admin/src/lib/adapter.ts","webpack:///./admin/src/pages/settings.tsx","webpack:///./src/lib/promises.ts"],"sourcesContent":["// tslint:disable-next-line:no-reference\r\n/// <reference path=\"../../src/lib/ioBroker.d.ts\" />\r\n\r\n// root objects\r\nimport * as $ from \"jquery\";\r\nimport * as React from \"react\";\r\nimport * as ReactDOM from \"react-dom\";\r\n\r\nimport { promisify } from \"../../src/lib/promises\";\r\nimport { $$, $window, _, instance, sendTo, socket } from \"./lib/adapter\";\r\n\r\n// components\r\nimport { OnSettingsChangedCallback, Settings, TVInfo } from \"./pages/settings\";\r\n\r\nconst namespace = `philips-tv.${instance}`;\r\n\r\n// layout components\r\nfunction Header() {\r\n\treturn (\r\n\t\t<h3 className=\"translate\" data-role=\"adapter-name\">{_(\"Philips TV adapter settings\")}</h3>\r\n\t);\r\n}\r\n\r\nconst $emit = promisify<any>(socket.emit.bind(socket));\r\n\r\nexport class Root extends React.Component<any, { tvInfo: TVInfo, settings: Record<string, any> }> {\r\n\r\n\tconstructor(props) {\r\n\t\tsuper(props);\r\n\t\tthis.state = {\r\n\t\t\tsettings: this.props.settings,\r\n\t\t\ttvInfo: null,\r\n\t\t};\r\n\t}\r\n\r\n\tprivate updateTimer;\r\n\r\n\tpublic componentDidMount() {\r\n\t\t// subscribe to the TV state\r\n\t\tsocket.emit(\"subscribe\", namespace + \".info.*\");\r\n\t\tsocket.on(\"stateChange\", (id: string, state: ioBroker.State) => {\r\n\t\t\tif (id.substring(0, namespace.length) !== namespace) return;\r\n\t\t\tconsole.log(`state changed: ${id} => ${state.val}`);\r\n\t\t\tconst tvInfo = this.state.tvInfo;\r\n\t\t\tif (id.match(/info\\.apiVersion/)) {\r\n\t\t\t\ttvInfo.apiVersion = state.val;\r\n\t\t\t\tthis.setState({ tvInfo });\r\n\t\t\t} else if (id.match(/info\\.requiresPairing/)) {\r\n\t\t\t\ttvInfo.requiresPairing = state.val;\r\n\t\t\t\tthis.setState({ tvInfo });\r\n\t\t\t} else if (id.match(/info\\.paired/)) {\r\n\t\t\t\ttvInfo.paired = state.val;\r\n\t\t\t\tthis.setState({ tvInfo });\r\n\t\t\t}\r\n\t\t});\r\n\t\t// and unsubscribe when the window gets unloaded\r\n\t\t$$(window).on(\"beforeunload\", () => {\r\n\t\t\tsocket.emit(\"unsubscribe\", namespace + \".info.*\");\r\n\t\t\treturn null;\r\n\t\t});\r\n\r\n\t\t// wait for the adapter to get the TV's information\r\n\t\tthis.updateTVInfo();\r\n\t}\r\n\r\n\tpublic componentWillUnmount() {\r\n\t\tif (this.updateTimer != null) clearInterval(this.updateTimer);\r\n\t}\r\n\r\n\tpublic async updateTVInfo() {\r\n\t\ttry {\r\n\t\t\tconst states = {\r\n\t\t\t\tapiVersion: await $emit(\"getState\", `${namespace}.info.apiVersion`),\r\n\t\t\t\trequiresPairing: await $emit(\"getState\", `${namespace}.info.requiresPairing`),\r\n\t\t\t\tpaired: await $emit(\"getState\", `${namespace}.info.paired`),\r\n\t\t\t};\r\n\t\t\tthis.setState({\r\n\t\t\t\ttvInfo: {\r\n\t\t\t\t\tapiVersion: states.apiVersion ? states.apiVersion.val : null,\r\n\t\t\t\t\trequiresPairing: states.requiresPairing ? states.requiresPairing.val : null,\r\n\t\t\t\t\tpaired: states.paired ? states.paired.val : null,\r\n\t\t\t\t},\r\n\t\t\t});\r\n\t\t} catch (e) {\r\n\t\t\tconsole.error(e);\r\n\t\t}\r\n\t}\r\n\r\n\tpublic render() {\r\n\t\treturn (\r\n\t\t\t<>\r\n\t\t\t\t<Header />\r\n\t\t\t\t<Settings settings={this.state.settings} onChange={this.props.onSettingsChanged} tvInfo={this.state.tvInfo} />\r\n\t\t\t</>\r\n\t\t);\r\n\t}\r\n\r\n}\r\n\r\nlet curSettings: Record<string, any>;\r\nlet originalSettings: Record<string, any>;\r\n\r\n/**\r\n * Checks if any setting was changed\r\n */\r\nfunction hasChanges(): boolean {\r\n\tfor (const key of Object.keys(originalSettings)) {\r\n\t\tif (originalSettings[key] !== curSettings[key]) return true;\r\n\t}\r\n\treturn false;\r\n}\r\n\r\n// the function loadSettings has to exist ...\r\n$window.load = (settings, onChange) => {\r\n\r\n\toriginalSettings = settings;\r\n\r\n\tconst settingsChanged: OnSettingsChangedCallback = (newSettings) => {\r\n\t\tcurSettings = newSettings;\r\n\t\tonChange(hasChanges());\r\n\t};\r\n\r\n\tReactDOM.render(\r\n\t\t<Root settings={settings} onSettingsChanged={settingsChanged} />,\r\n\t\tdocument.getElementById(\"adapter-container\"),\r\n\t);\r\n\r\n\t// Signal to admin, that no changes yet\r\n\tonChange(false);\r\n};\r\n\r\n// ... and the function save has to exist.\r\n// you have to make sure the callback is called with the settings object as first param!\r\n$window.save = (callback) => {\r\n\t// save the settings\r\n\tcallback(curSettings);\r\n\toriginalSettings = curSettings;\r\n};\r\n\n\n\n// WEBPACK FOOTER //\n// ./admin/src/index.tsx","// fix missing property errors/warnings\r\ninterface SendToResult {\r\n\terror?: string | Error;\r\n\tresult?: any;\r\n}\r\nexport const $window = window as any as {\r\n\tload: (settings, onChange) => void;\r\n\tsave: (callback: (settings) => void) => void;\r\n\treadonly instance: number;\r\n\t/** Translates text */\r\n\t_: (text: string) => string;\r\n\tjQuery: JQueryStatic;\r\n\t$: JQueryStatic;\r\n\tsocket: any;\r\n\tsendTo: (instance: any | null, command: string, message: any, callback: (result: SendToResult) => void) => void;\r\n};\r\nexport interface JQueryUI {\r\n\ttabs: (selector?: any) => JQuery & JQueryUI;\r\n\tbutton: (selector?: any) => JQuery & JQueryUI;\r\n\tmultiselect: (selector?: any) => JQuery & JQueryUI;\r\n}\r\nexport const $$ = $window.jQuery as any as (...args: any[]) => JQuery & JQueryUI;\r\nexport const instance = $window.instance || 0;\r\nexport const _ = $window._ || ((text: string) => text);\r\nexport const socket = $window.socket;\r\nexport const sendTo = $window.sendTo;\r\n\n\n\n// WEBPACK FOOTER //\n// ./admin/src/lib/adapter.ts","import * as React from \"react\";\r\nimport * as ReactDOM from \"react-dom\";\r\n\r\nimport { APIVersion } from \"../../../src/api\";\r\nimport {$$, $window, _, instance} from \"../lib/adapter\";\r\n\r\nexport type OnSettingsChangedCallback = (newSettings: Record<string, any>) => void;\r\nexport interface TVInfo {\r\n\tapiVersion: APIVersion | \"not found\";\r\n\trequiresPairing?: boolean;\r\n\tpaired?: boolean;\r\n}\r\n\r\ninterface SettingsProps {\r\n\tonChange: OnSettingsChangedCallback;\r\n\tsettings: Record<string, any>;\r\n\ttvInfo: TVInfo;\r\n}\r\n\r\n/** Helper component for a settings label */\r\nfunction Label(props) {\r\n\treturn <label htmlFor={props.for} className={(props.class || []).join(\" \")}>{_(props.text)} </label>;\r\n}\r\n/** Helper component for a tooltip */\r\nfunction Tooltip(props) {\r\n\treturn <img className=\"admin-tooltip-icon\" src=\"../../img/info.png\" title={_(props.text)} />;\r\n}\r\n\r\nexport class Settings extends React.Component<SettingsProps, Record<string, any>> {\r\n\r\n\tconstructor(props: SettingsProps) {\r\n\t\tsuper(props);\r\n\t\t// settings are our state\r\n\t\tthis.state = {\r\n\t\t\t...props.settings,\r\n\t\t};\r\n\t\t// remember the original settings\r\n\t\tthis.originalSettings = {...props.settings};\r\n\r\n\t\t// setup change handlers\r\n\t\tthis.handleChange = this.handleChange.bind(this);\r\n\t}\r\n\r\n\tprivate onChange: OnSettingsChangedCallback;\r\n\tprivate originalSettings: Record<string, any>;\r\n\r\n\t// gets called when the form elements are changed by the user\r\n\tprivate handleChange(event: React.FormEvent<HTMLElement>) {\r\n\t\tconst target = event.target as (HTMLInputElement | HTMLSelectElement); // TODO: more types\r\n\r\n\t\t// store the setting\r\n\t\tthis.putSetting(target.id, target.value, () => {\r\n\t\t\t// and notify the admin UI about changes\r\n\t\t\tthis.props.onChange(this.state);\r\n\t\t});\r\n\t}\r\n\r\n\t/**\r\n\t * Reads a setting from the state object and transforms the value into the correct format\r\n\t * @param key The setting key to lookup\r\n\t */\r\n\tprivate getSetting(key: string): string | number | string[] {\r\n\t\treturn this.state[key] as any;\r\n\t}\r\n\t/**\r\n\t * Saves a setting in the state object and transforms the value into the correct format\r\n\t * @param key The setting key to store at\r\n\t */\r\n\tprivate putSetting(key: string, value: string | number | string[], callback?: () => void): void {\r\n\t\tthis.setState({[key]: value as any}, callback);\r\n\t}\r\n\r\n\tpublic render() {\r\n\t\tconsole.log(\"rendering... this.props.tvInfo = \" + JSON.stringify(this.props.tvInfo));\r\n\t\treturn (\r\n\t\t\t<p key=\"content\" className=\"settings-table\">\r\n\t\t\t\t<Label for=\"host\" text=\"Hostname/IP:\" />\r\n\t\t\t\t<Tooltip text=\"hostname tooltip\" />\r\n\t\t\t\t<input className=\"value\" id=\"host\" value={this.getSetting(\"host\")} onChange={this.handleChange} />\r\n\t\t\t\t<span>{_(\"wait for API test\")}</span>\r\n\t\t\t\t<br />\r\n\r\n\t\t\t\t{this.props.tvInfo && ((this.props.tvInfo.apiVersion !== \"not found\") ? (\r\n\t\t\t\t\tthis.props.tvInfo.requiresPairing && (\r\n\t\t\t\t\t\tthis.props.tvInfo.paired ? (\r\n\t\t\t\t\t\t\t<span>{_(\"connected\")}</span>\r\n\t\t\t\t\t\t) : (\r\n\t\t\t\t\t\t\t<span>{_(\"needs pairing\")}</span>\r\n\t\t\t\t\t\t)\r\n\t\t\t\t\t)\r\n\t\t\t\t) : (\r\n\t\t\t\t\t<span>{_(\"no TV found\")}</span>\r\n\t\t\t\t))}\r\n\t\t\t</p>\r\n\t\t);\r\n\t}\r\n}\r\n\n\n\n// WEBPACK FOOTER //\n// ./admin/src/pages/settings.tsx","///\r\n/// Stellt einen Promise-Wrapper für asynchrone Node-Funktionen zur Verfügung\r\n///\r\n\r\n// tslint:disable:ban-types\r\nexport function promisify<T>(fn: Function, context?: any): (...args: any[]) => Promise<T>;\r\nexport function promisify(fn: Function, context?: any) {\r\n\treturn function(...args: any[]) {\r\n\t\tcontext = context || this;\r\n\t\treturn new Promise((resolve, reject) => {\r\n\t\t\tfn.apply(context, [...args, (error: Error, result: any) => {\r\n\t\t\t\tif (error) {\r\n\t\t\t\t\treturn reject(error);\r\n\t\t\t\t} else {\r\n\t\t\t\t\treturn resolve(result);\r\n\t\t\t\t}\r\n\t\t\t}]);\r\n\t\t});\r\n\t};\r\n}\r\n\r\nexport function promisifyNoError<T>(fn: Function, context?: any): (...args: any[]) => Promise<T>;\r\nexport function promisifyNoError(fn: Function, context?: any) {\r\n\treturn function(...args: any[]) {\r\n\t\tcontext = context || this;\r\n\t\treturn new Promise((resolve) => {\r\n\t\t\tfn.apply(context, [...args, (result: any) => {\r\n\t\t\t\treturn resolve(result);\r\n\t\t\t}]);\r\n\t\t});\r\n\t};\r\n}\r\n// tslint:enable:ban-types\r\n\r\n/** Creates a promise that waits for the specified time and then resolves */\r\nexport function wait(ms: number): Promise<void> {\r\n\treturn new Promise<void>((resolve) => {\r\n\t\tsetTimeout(resolve, ms);\r\n\t});\r\n}\r\n\n\n\n// WEBPACK FOOTER //\n// ./src/lib/promises.ts"],"mappings":";;;;;;;AAAA;AACA;;;;;;;;;;AAIA;AACA;AAEA;AACA;AAEA;AACA;AAEA;AAEA;AACA;AACA;AAGA;AAEA;AAEA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AAIA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AAAA;AACA;AAEA;;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AAAA;AAEA;AACA;AAEA;AACA;AAGA;AAEA;AAxEA;AA0EA;AACA;AAEA;;AAEA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AAEA;AACA;AAEA;AAEA;AACA;AACA;AACA;AAEA;AAKA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;ACpIA;AAgBA;AACA;AACA;AACA;AACA;;;;;;;;;;;ACzBA;AAIA;AAeA;AACA;AACA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AAEA;AAEA;AACA;AACA;AACA;AAGA;AACA;AAEA;AACA;AACA;AAKA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AAEA;;;AAGA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AAaA;AACA;AApEA;;;;;;;;;;AC5BA;AACA;AACA;;AAIA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AAbA;AAgBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AATA;AAUA;AAEA;AACA;AACA;AACA;AACA;AACA;AAJA;;;;;A","sourceRoot":""}